{
	"metadata": {
		"type": "App"
	},
	"project": {
		"shadows": true,
		"vr": false
	},
	"camera": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "9765F0BD-5265-4061-8C37-E77AF1206063",
			"type": "PerspectiveCamera",
			"name": "Camera",
			"layers": 1,
			"matrix": [0.9987502603949661,0,-0.049979169270682,0,-0.01205717962894617,0.9704644686913524,-0.24094260608494797,0,0.048503007951907574,0.24124409838918562,0.9692516408095506,0,0.8472082702785049,4.028370064843758,10.557947249245636,1],
			"fov": 50,
			"zoom": 1,
			"near": 1,
			"far": 10000,
			"focus": 10,
			"aspect": 1.100111234705228,
			"filmGauge": 35,
			"filmOffset": 0
		}
	},
	"scene": {
		"metadata": {
			"version": 4.5,
			"type": "Object",
			"generator": "Object3D.toJSON"
		},
		"object": {
			"uuid": "01205619-F086-4202-B929-71861BC1E509",
			"type": "Scene",
			"name": "Scene",
			"layers": 1,
			"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
			"children": [
				{
					"uuid": "037ED138-2B13-485A-A232-9113F54FF3B2",
					"type": "Group",
					"name": "Ground",
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				},
				{
					"uuid": "4B82BA84-EB8D-40C0-A930-0870060807B3",
					"type": "Group",
					"name": "LocalPlayer",
					"visible": false,
					"layers": 1,
					"matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
				}],
			"background": 11184810
		}
	},
	"scripts": {
		"01205619-F086-4202-B929-71861BC1E509": [
			{
				"name": "MW.js",
				"source": "// MW.js\n\n/*!\n* @author yomotsu http://yomotsu.net/\n* MIT License\n*/\n\nMW = {};\n\n\nMW.triangle = {};\n\n\nMW.triangle.makeBoundingBox = function ( triangle ) {\n\n  var bb = new THREE.Box3();\n\n  bb.min = bb.min.min( triangle.a );\n  bb.min = bb.min.min( triangle.b );\n  bb.min = bb.min.min( triangle.c );\n\n  bb.max = bb.max.max( triangle.a );\n  bb.max = bb.max.max( triangle.b );\n  bb.max = bb.max.max( triangle.c );\n\n  return bb;\n\n};\n\nMW.triangle.makeBoundingSphere = function ( triangle, normal ) {\n \n  var bs = new THREE.Sphere(),\n      v = new THREE.Vector3(),\n      v0 = new THREE.Vector3(),\n      v1 = new THREE.Vector3(),\n      e0 = new THREE.Vector3(),\n      e1 = new THREE.Vector3(),\n      a, b, c, d, e,\n      div, t, s;\n \n  // obtuse triangle\n \n  v0.subVectors( triangle.b, triangle.a );\n  v1.subVectors( triangle.c, triangle.a );\n \n  if ( v0.dot( v1 ) <= 0 ) {\n \n    bs.center.addVectors( triangle.b, triangle.c ).divideScalar( 2 );\n    bs.radius = v.subVectors( triangle.b, triangle.c ).length() / 2;\n    return bs;\n \n  }\n \n  v0.subVectors( triangle.a, triangle.b );\n  v1.subVectors( triangle.c, triangle.b );\n \n  if ( v0.dot( v1 ) <= 0 ) {\n \n    bs.center.addVectors( triangle.a, triangle.c ).divideScalar( 2 );\n    bs.radius = v.subVectors( triangle.a, triangle.c ).length() / 2;\n    return bs;\n \n  }\n \n  v0.subVectors( triangle.a, triangle.c );\n  v1.subVectors( triangle.b, triangle.c );\n \n  if ( v0.dot( v1 ) <= 0 ) {\n \n    bs.center.addVectors( triangle.a, triangle.b ).divideScalar( 2 );\n    bs.radius = v.subVectors( triangle.a, triangle.b ).length() / 2;\n    return bs;\n \n  }\n \n  // acute‐angled triangle\n \n  if ( !normal ) {\n \n    normal = triangle.normal();\n \n  }\n \n  v0.crossVectors( v.subVectors( triangle.c, triangle.b ), normal );\n  v1.crossVectors( v.subVectors( triangle.c, triangle.a ), normal );\n \n  e0.addVectors( triangle.c, triangle.b ).multiplyScalar( .5 );\n  e1.addVectors( triangle.c, triangle.a ).multiplyScalar( .5 );\n \n  a = v0.dot( v1 );\n  b = v0.dot( v0 );\n  d = v1.dot( v1 );\n  c = -v.subVectors( e1, e0 ).dot( v0 );\n  e = -v.subVectors( e1, e0 ).dot( v1 );\n \n  div = - a * a + b * d;\n  // t = ( - a * c + b * e ) / div;\n  s = ( - c * d + a * e ) / div;\n \n  bs.center = e0.clone().add( v0.clone().multiplyScalar( s ) );\n  bs.radius = v.subVectors( bs.center, triangle.a ).length();\n  return bs;\n \n}\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  ns.collision = {};\n\n  // aabb: <THREE.Box3>\n  // Plane: <THREE.Plane>\n  ns.collision.isIntersectionAABBPlane = function ( aabb, Plane ) {\n\n    var center = new THREE.Vector3().addVectors( aabb.max, aabb.min ).multiplyScalar( 0.5 ),\n        extents = new THREE.Vector3().subVectors( aabb.max, center );\n\n    var r = extents.x * Math.abs( Plane.normal.x ) + extents.y * Math.abs( Plane.normal.y ) + extents.z * Math.abs( Plane.normal.z );\n    var s = Plane.normal.dot( center ) - Plane.constant;\n\n    return Math.abs( s ) <= r;\n\n  };\n\n  // based on http://www.gamedev.net/topic/534655-aabb-triangleplane-intersection--distance-to-plane-is-incorrect-i-have-solved-it/\n  //\n  // a: <THREE.Vector3>, // vertex of a triangle\n  // b: <THREE.Vector3>, // vertex of a triangle\n  // c: <THREE.Vector3>, // vertex of a triangle\n  // aabb: <THREE.Box3>\n  ns.collision.isIntersectionTriangleAABB = function ( a, b, c, aabb ) {\n\n    var p0, p1, p2, r;\n    \n    // Compute box center and extents of AABoundingBox (if not already given in that format)\n    var center = new THREE.Vector3().addVectors( aabb.max, aabb.min ).multiplyScalar( 0.5 ),\n        extents = new THREE.Vector3().subVectors( aabb.max, center );\n\n    // Translate triangle as conceptually moving AABB to origin\n    var v0 = new THREE.Vector3().subVectors( a, center ),\n        v1 = new THREE.Vector3().subVectors( b, center ),\n        v2 = new THREE.Vector3().subVectors( c, center );\n\n    // Compute edge vectors for triangle\n    var f0 = new THREE.Vector3().subVectors( v1, v0 ),\n        f1 = new THREE.Vector3().subVectors( v2, v1 ),\n        f2 = new THREE.Vector3().subVectors( v0, v2 );\n\n    // Test axes a00..a22 (category 3)\n    var a00 = new THREE.Vector3( 0, -f0.z, f0.y ),\n        a01 = new THREE.Vector3( 0, -f1.z, f1.y ),\n        a02 = new THREE.Vector3( 0, -f2.z, f2.y ),\n        a10 = new THREE.Vector3( f0.z, 0, -f0.x ),\n        a11 = new THREE.Vector3( f1.z, 0, -f1.x ),\n        a12 = new THREE.Vector3( f2.z, 0, -f2.x ),\n        a20 = new THREE.Vector3( -f0.y, f0.x, 0 ),\n        a21 = new THREE.Vector3( -f1.y, f1.x, 0 ),\n        a22 = new THREE.Vector3( -f2.y, f2.x, 0 );\n\n    // Test axis a00\n    p0 = v0.dot( a00 );\n    p1 = v1.dot( a00 );\n    p2 = v2.dot( a00 );\n    r = extents.y * Math.abs( f0.z ) + extents.z * Math.abs( f0.y );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a01\n    p0 = v0.dot( a01 );\n    p1 = v1.dot( a01 );\n    p2 = v2.dot( a01 );\n    r = extents.y * Math.abs( f1.z ) + extents.z * Math.abs( f1.y );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a02\n    p0 = v0.dot( a02 );\n    p1 = v1.dot( a02 );\n    p2 = v2.dot( a02 );\n    r = extents.y * Math.abs( f2.z ) + extents.z * Math.abs( f2.y );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a10\n    p0 = v0.dot( a10 );\n    p1 = v1.dot( a10 );\n    p2 = v2.dot( a10 );\n    r = extents.x * Math.abs( f0.z ) + extents.z * Math.abs( f0.x );\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a11\n    p0 = v0.dot( a11 );\n    p1 = v1.dot( a11 );\n    p2 = v2.dot( a11 );\n    r = extents.x * Math.abs( f1.z ) + extents.z * Math.abs( f1.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a12\n    p0 = v0.dot( a12 );\n    p1 = v1.dot( a12 );\n    p2 = v2.dot( a12 );\n    r = extents.x * Math.abs( f2.z ) + extents.z * Math.abs( f2.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a20\n    p0 = v0.dot( a20 );\n    p1 = v1.dot( a20 );\n    p2 = v2.dot( a20 );\n    r = extents.x * Math.abs( f0.y ) + extents.y * Math.abs( f0.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a21\n    p0 = v0.dot( a21 );\n    p1 = v1.dot( a21 );\n    p2 = v2.dot( a21 );\n    r = extents.x * Math.abs( f1.y ) + extents.y * Math.abs( f1.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test axis a22\n    p0 = v0.dot( a22 );\n    p1 = v1.dot( a22 );\n    p2 = v2.dot( a22 );\n    r = extents.x * Math.abs( f2.y ) + extents.y * Math.abs( f2.x );\n\n    if ( Math.max( -Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n      return false; // Axis is a separating axis\n\n    }\n\n    // Test the three axes corresponding to the face normals of AABB b (category 1).\n    // Exit if...\n    // ... [-extents.x, extents.x] and [min(v0.x,v1.x,v2.x), max(v0.x,v1.x,v2.x)] do not overlap\n    if ( Math.max( v0.x, v1.x, v2.x ) < -extents.x || Math.min( v0.x, v1.x, v2.x ) > extents.x ) {\n\n      return false;\n\n    }\n    // ... [-extents.y, extents.y] and [min(v0.y,v1.y,v2.y), max(v0.y,v1.y,v2.y)] do not overlap\n    if ( Math.max( v0.y, v1.y, v2.y ) < -extents.y || Math.min( v0.y, v1.y, v2.y ) > extents.y ) {\n\n      return false;\n\n    }\n    // ... [-extents.z, extents.z] and [min(v0.z,v1.z,v2.z), max(v0.z,v1.z,v2.z)] do not overlap\n    if ( Math.max( v0.z, v1.z, v2.z ) < -extents.z || Math.min( v0.z, v1.z, v2.z ) > extents.z ) {\n\n      return false;\n\n    }\n\n    // Test separating axis corresponding to triangle face normal (category 2)\n    // Face Normal is -ve as Triangle is clockwise winding (and XNA uses -z for into screen)\n    var plane = new THREE.Plane();\n    plane.normal = new THREE.Vector3().copy( f1 ).cross( f0 ).normalize();\n    plane.constant = plane.normal.dot( a );\n    \n    return ns.collision.isIntersectionAABBPlane( aabb, plane );\n\n  };\n\n\n  // sphere1: <THREE.Sphere>\n  // sphere2: <THREE.Sphere>\n  ns.collision.isIntersectionSphereSphere = function ( sphere1, sphere2 ) {\n\n    var radiusSum = sphere1.radius + sphere2.radius;\n\n    return sphere1.center.distanceToSquared( sphere2.center ) <= ( radiusSum * radiusSum );\n\n  };\n\n  // Section 5.1.3\n  // sphere: <THREE.Sphere>\n  // aabb: <THREE.Box3>\n\n  ns.collision.isIntersectionSphereAABB = function ( sphere, aabb ) {\n\n    var sqDist = 0;\n\n    if ( sphere.center.x < aabb.min.x ) { sqDist += ( aabb.min.x - sphere.center.x ) * ( aabb.min.x - sphere.center.x ); }\n    if ( sphere.center.x > aabb.max.x ) { sqDist += ( sphere.center.x - aabb.max.x ) * ( sphere.center.x - aabb.max.x ); }\n\n    if ( sphere.center.y < aabb.min.y ) { sqDist += ( aabb.min.y - sphere.center.y ) * ( aabb.min.y - sphere.center.y ); }\n    if ( sphere.center.y > aabb.max.y ) { sqDist += ( sphere.center.y - aabb.max.y ) * ( sphere.center.y - aabb.max.y ); }\n\n    if ( sphere.center.z < aabb.min.z ) { sqDist += ( aabb.min.z - sphere.center.z ) * ( aabb.min.z - sphere.center.z ); }\n    if ( sphere.center.z > aabb.max.z ) { sqDist += ( sphere.center.z - aabb.max.z ) * ( sphere.center.z - aabb.max.z ); }\n\n    return sqDist <= sphere.radius * sphere.radius;\n\n  };\n\n\n  //http://clb.demon.fi/MathGeoLib/docs/Triangle.cpp_code.html#459\n\n  // sphere: <THREE.Sphere>\n  // a: <THREE.Vector3>, // vertex of a triangle\n  // b: <THREE.Vector3>, // vertex of a triangle\n  // c: <THREE.Vector3>, // vertex of a triangle\n  // normal: <THREE.Vector3>, // normal of a triangle\n  ns.collision.isIntersectionSphereTriangle = function ( sphere, a, b, c, normal ) {\n    // http://realtimecollisiondetection.net/blog/?p=103\n\n    // vs plain of traiangle face\n    var A = new THREE.Vector3(),\n        B = new THREE.Vector3(),\n        C = new THREE.Vector3(),\n        rr,\n        V = new THREE.Vector3(),\n        d,\n        e;\n\n    A.subVectors( a, sphere.center );\n    B.subVectors( b, sphere.center );\n    C.subVectors( c, sphere.center );\n    rr = sphere.radius * sphere.radius;\n    V.crossVectors( B.clone().sub( A ), C.clone().sub( A ) );\n    d = A.dot( V );\n    e = V.dot( V );\n\n    if ( d * d > rr * e ) {\n\n      return false;\n\n    }\n\n    // vs triangle vertex\n    var aa,\n        ab,\n        ac,\n        bb,\n        bc,\n        cc;\n\n    aa = A.dot( A );\n    ab = A.dot( B );\n    ac = A.dot( C );\n    bb = B.dot( B );\n    bc = B.dot( C );\n    cc = C.dot( C );\n\n    if (\n      ( aa > rr ) & ( ab > aa ) & ( ac > aa ) ||\n      ( bb > rr ) & ( ab > bb ) & ( bc > bb ) ||\n      ( cc > rr ) & ( ac > cc ) & ( bc > cc )\n    ) {\n\n      return false;\n\n    }\n\n    // vs edge\n    var AB = new THREE.Vector3(),\n        BC = new THREE.Vector3(),\n        CA = new THREE.Vector3(),\n        d1,\n        d2,\n        d3,\n        e1,\n        e2,\n        e3,\n        Q1 = new THREE.Vector3(),\n        Q2 = new THREE.Vector3(),\n        Q3 = new THREE.Vector3(),\n        QC = new THREE.Vector3(),\n        QA = new THREE.Vector3(),\n        QB = new THREE.Vector3();\n\n    AB.subVectors( B, A );\n    BC.subVectors( C, B );\n    CA.subVectors( A, C );\n    d1 = ab - aa;\n    d2 = bc - bb;\n    d3 = ac - cc;\n    e1 = AB.dot( AB );\n    e2 = BC.dot( BC );\n    e3 = CA.dot( CA );\n    Q1.subVectors( A.multiplyScalar( e1 ), AB.multiplyScalar( d1 ) );\n    Q2.subVectors( B.multiplyScalar( e2 ), BC.multiplyScalar( d2 ) );\n    Q3.subVectors( C.multiplyScalar( e3 ), CA.multiplyScalar( d3 ) );\n    QC.subVectors( C.multiplyScalar( e1 ), Q1 );\n    QA.subVectors( A.multiplyScalar( e2 ), Q2 );\n    QB.subVectors( B.multiplyScalar( e3 ), Q3 );\n\n    if (\n      ( Q1.dot( Q1 ) > rr * e1 * e1 ) && ( Q1.dot( QC ) >= 0 ) ||\n      ( Q2.dot( Q2 ) > rr * e2 * e2 ) && ( Q2.dot( QA ) >= 0 ) ||\n      ( Q3.dot( Q3 ) > rr * e3 * e3 ) && ( Q3.dot( QB ) >= 0 )\n    ) {\n\n      return false;\n\n    }\n\n    var distance = Math.sqrt( d * d / e ) - sphere.radius - 1,\n        contactPoint = new THREE.Vector3(),\n        negatedNormal = new THREE.Vector3( -normal.x, -normal.y, -normal.z );\n\n    contactPoint.copy( sphere.center ).add( negatedNormal.multiplyScalar( distance ) );\n\n    return {\n      distance    : distance,\n      contactPoint: contactPoint\n    };\n\n  };\n\n  // based on Real-Time Collision Detection Section 5.3.4\n  // p: <THREE.Vector3>, // line3.start\n  // q: <THREE.Vector3>, // line3.end\n  // a: <THREE.Vector3>, // triangle.a\n  // b: <THREE.Vector3>, // triangle.b\n  // c: <THREE.Vector3>, // triangle.c\n  // normal: <THREE.Vector3>, // triangle.normal, optional\n\n  // var scalarTriple = function ( a, b, c ) {\n\n  //   var m = b.clone().cross( c );\n  //   return a.dot( m );\n\n  // }\n\n  // var vectorTriple = function ( a, b, c ) {\n\n  //   var m = b.clone().cross( c );\n  //   return a.clone().cross( m );\n\n  // }\n\n  // ns.collision.isIntersectionLineTriangle = function ( p, q, a, b, c, precision ) {\n\n  //   var pq = q.clone().sub( p ),\n  //       pa = a.clone().sub( p ),\n  //       pb = b.clone().sub( p ),\n  //       pc = c.clone().sub( p ),\n  //       u, v, w;\n\n  //   u = scalarTriple( pq, pc, pb );\n\n  //   if ( u < 0 ) { return false; }\n\n  //   v = scalarTriple( pq, pa, pc );\n\n  //   if ( v < 0 ) { return false; }\n\n  //   w = scalarTriple( pq, pb, pa );\n\n  //   if ( w < 0 ) { return false; }\n\n  //   var denom = 1 / ( u + v + w );\n  //   u *= denom;\n  //   v *= denom;\n  //   w *= denom;\n\n  //   var au = a.clone().multiplyScalar( u ),\n  //       bv = b.clone().multiplyScalar( v ),\n  //       cw = c.clone().multiplyScalar( w ),\n  //       contactPoint = au.clone().add( bv ).add( cw );\n\n  //   return {\n  //     contactPoint: contactPoint\n  //   }\n\n  // }\n\n  ns.collision.testSegmentTriangle = function ( p, q, a, b, c ) {\n\n    var ab = b.clone().sub( a );\n    var ac = c.clone().sub( a );\n    var qp = p.clone().sub( q );\n\n    var n = ab.clone().cross( ac );\n\n    var d = qp.dot( n );\n    if ( d <= 0 ) { return false; }\n\n    var ap = p.clone().sub( a );\n    var t = ap.dot( n );\n\n    if ( t < 0 ) { return 0; }\n    if ( t > d ) { return 0; }\n\n    var e = qp.clone().cross( ap );\n    var v = ac.dot( e );\n\n    if ( v < 0 || v > d ) { return 0; }\n\n    var w = ab.clone().dot( e ) * -1;\n\n    if ( w < 0 || v + w > d ) { return 0; }\n\n    var ood = 1 / d;\n    t *= ood;\n    v *= ood;\n    w *= ood;\n    var u = 1 - v - w;\n\n    var au = a.clone().multiplyScalar( u ),\n        bv = b.clone().multiplyScalar( v ),\n        cw = c.clone().multiplyScalar( w ),\n        contactPoint = au.clone().add( bv ).add( cw );\n\n    return {\n      contactPoint: contactPoint\n    }\n\n}\n\n} )( THREE, MW );\n\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  ns.World = function () {\n\n    // console.log( 'THREEFIELD.World' );\n\n    this.colliderPool  = [];\n    this.characterPool = [];\n\n  };\n\n  ns.World.prototype.add = function ( object ) {\n    \n    if ( object instanceof ns.Octree ) {\n\n      this.colliderPool.push( object );\n\n    } else if ( object instanceof ns.CharacterController ) {\n\n      this.characterPool.push( object );\n      object.world = this;\n\n    }\n\n  };\n\n  ns.World.prototype.step = function ( dt ) {\n\n    var character,\n        octree,\n        sphere,\n        intersectedNodes,\n        faces,\n        contactInfo,\n        i, ii, iii, l, ll, lll;\n\n    for ( i = 0, l = this.characterPool.length; i < l; i ++ ) {\n\n      character = this.characterPool[ i ];\n\n      // octree で絞られた node に含まれる face だけを\n      // charactore に渡して判定する\n      for ( ii = 0, ll = this.colliderPool.length; ii < ll; ii ++ ) {\n\n        octree = this.colliderPool[ ii ];\n        sphere = new THREE.Sphere( character.center, character.radius + character.groundPadding );\n        intersectedNodes = octree.getIntersectedNodes( sphere, octree.maxDepth );\n        faces = ns.Octree.uniqTriangkesfromNodes( intersectedNodes );\n\n      }\n      \n      character.collisionCandidate = faces;\n      character.update( dt );\n\n    }\n\n  };\n\n} )( THREE, MW );\n\n// @author yomotsu\n// MIT License\n\n// OcTree with Morton Order\n// based on http://marupeke296.com/COL_3D_No15_Octree.html\n//\n//       +------+------+\n//       |\\   2  \\   3  \\\n//       | +------+------+\n//       + |\\      \\      \\\n//       |\\| +------+------+\n//       | + |      |      |\n//       +0|\\|   6  |   7  |\n//        \\| +------+------+\n//         + |      |      |\n//    y     \\|   4  |   5  |\n//    |      +------+------+\n//    +--x\n//     \\\n//      z\n//\n//\n//       +------+------+\n//       |\\   6  \\   7  \\\n//       | +------+------+\n//       + |\\      \\      \\\n//       |\\| +------+------+\n//       | + |      |      |\n//       +4|\\|   2  |   3  |\n//        \\| +------+------+\n//         + |      |      |\n//  z y     \\|   0  |   1  |\n//   \\|      +------+------+\n//    +--x\n//\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  // min: <THREE.Vector3>\n  // max: <THREE.Vector3>\n  // maxDepth: <Number>\n  ns.Octree = function ( min, max, maxDepth ) {\n\n    this.min = min;\n    this.max = max;\n    this.maxDepth = maxDepth;\n    this.nodes = [];\n\n    var i, length, depth, mortonNumber,\n        pow2, pow4,\n        indexX, indexY, indexZ,\n        nodeBoxSize = new THREE.Vector3(),\n        nodeBoxMin = new THREE.Vector3(),\n        nodeBoxMax = new THREE.Vector3();\n\n    for ( depth = 0; depth < this.maxDepth; depth ++ ) {\n\n      this.nodes.push( [] );\n      pow2 = Math.pow( 2, depth );\n      pow4 = Math.pow( 4, depth );\n      nodeBoxSize.subVectors( this.max, this.min ).divideScalar( pow2 );\n\n      for ( i = 0, length = Math.pow( 8, depth ); i < length; i ++ ) {\n\n        indexX = i % pow2;\n        indexY = ( i / pow4 )|0;\n        indexZ = ( ( i / pow2 )|0 ) % pow2;\n\n        nodeBoxMin.set(\n          this.min.x + indexX * nodeBoxSize.x,\n          this.min.y + indexY * nodeBoxSize.y,\n          this.min.z + indexZ * nodeBoxSize.z\n        );\n        nodeBoxMax.copy( nodeBoxMin ).add( nodeBoxSize );\n\n        mortonNumber = ns.Octree.getMortonNumber( indexX, indexY, indexZ );\n        this.nodes[ depth ][ mortonNumber ] = new ns.OctreeNode( this, depth, mortonNumber, nodeBoxMin, nodeBoxMax );\n\n      }\n\n    }\n\n  };\n\n  ns.Octree.prototype = {\n\n    constructor: ns.Octree,\n\n    importThreeMesh: function ( threeMesh ) {\n\n\n      var i, ii, l, ll,\n          vec3 = new THREE.Vector3(),\n          geometry,\n          geometryId,\n          face,\n          normal,\n          index,\n          count,\n          start,\n          a, b, c,\n        \tvA  = new THREE.Vector3(),\n        \tvB  = new THREE.Vector3(),\n        \tvC  = new THREE.Vector3(),\n        \tvnA = new THREE.Vector3(),\n        \tvnB = new THREE.Vector3(),\n        \tvnC = new THREE.Vector3(),\n          ab  = new THREE.Vector3(),\n          cb  = new THREE.Vector3(),\n          faceNormal;\n\n      threeMesh.updateMatrix();\n\n      geometryId = threeMesh.geometry.uuid;\n      geometry   = threeMesh.geometry.clone();\n      geometry.applyMatrix( threeMesh.matrix );\n      geometry.computeVertexNormals();\n\n      if ( geometry instanceof THREE.BufferGeometry ) {\n\n        if ( geometry.index !== undefined ) {\n\n          var indices   = geometry.index.array;\n          var positions = geometry.attributes.position.array;\n          var normals   = geometry.attributes.normal.array;\n          var offsets   = geometry.groups;\n\n          if ( offsets.length === 0 ) {\n\n            offsets = [ { start: 0, count: indices.length, index: 0 } ];\n\n          }\n\n          for ( i = 0, l = offsets.length; i < l; ++ i ) {\n\n            start  = offsets[ i ].start;\n            count  = offsets[ i ].count;\n            index  = offsets[ i ].materialIndex;\n\n            for ( ii = start, ll = start + count; ii < ll; ii += 3 ) {\n\n              a = index + indices[ ii ];\n              b = index + indices[ ii + 1 ];\n              c = index + indices[ ii + 2 ];\n\n              vA = vec3.fromArray( positions, a * 3 ).clone();\n              vB = vec3.fromArray( positions, b * 3 ).clone();\n              vC = vec3.fromArray( positions, c * 3 ).clone();\n\n              // https://github.com/mrdoob/three.js/issues/4691\n              // make face normal\n              cb.subVectors( vC, vB );\n              ab.subVectors( vA, vB );\n              faceNormal = cb.cross( ab ).normalize().clone();\n\n              face = new ns.Face(\n                vA,\n                vB,\n                vC,\n                faceNormal,\n                geometryId\n              );\n\n              this.addFace( face );\n\n            }\n\n          }\n\n        }\n\n        return;\n\n      }\n\n      geometry.computeFaceNormals();\n\n      for ( i = 0, l = geometry.faces.length; i < l; i ++ ) {\n\n        face = new ns.Face(\n          geometry.vertices[ geometry.faces[ i ].a ],\n          geometry.vertices[ geometry.faces[ i ].b ],\n          geometry.vertices[ geometry.faces[ i ].c ],\n          geometry.faces[ i ].normal,\n          geometryId\n        );\n        this.addFace( face );\n\n      }\n\n    },\n\n    addFace: function ( face ) {\n\n      var i, ii, l, ll, node, targetNodes = [], tmp = [], isIntersected;\n\n      targetNodes = this.nodes[ 0 ].slice( 0 );\n\n      for ( i = 0, l = this.maxDepth; i < l; i ++ ) {\n\n        for ( ii = 0, ll = targetNodes.length; ii < ll; ii ++ ) {\n\n          node = targetNodes[ ii ];\n          isIntersected = ns.collision.isIntersectionTriangleAABB( face.a, face.b, face.c, node );\n\n          if ( isIntersected ) {\n\n            node.trianglePool.push( face );\n\n            if ( i + 1 !== this.maxDepth ) {\n\n              tmp = tmp.concat( node.getChildNodes() );\n\n            }\n\n          }\n\n        }\n\n        if ( tmp.length === 0 ) {\n\n          break;\n\n        }\n\n        targetNodes = tmp.slice( 0 );\n        tmp.length = 0;\n\n      }\n\n    },\n\n    removeThreeMesh: function ( meshID ) {\n\n      var that = this;\n\n      this.nodes.forEach( function ( nodeDepth ) {\n\n        nodeDepth.forEach( function ( node ) {\n\n          var newTrianglePool = [];\n\n          node.trianglePool.forEach( function ( face ) {\n\n            if ( face.meshID !== meshID ) {\n\n              newTrianglePool.push( face );\n\n            }\n\n          } );\n\n          node.trianglePool = newTrianglePool;\n\n        } );\n\n      } );\n\n    },\n\n    getIntersectedNodes: function ( sphere, depth ) {\n\n      var i, ii, l, ll, node, targetNodes = [], tmp = [],\n          isIntersected, intersectedNodes = [], isAtMaxDepth;\n\n      isIntersected = ns.collision.isIntersectionSphereAABB( sphere, this );\n\n      if ( !isIntersected ) {\n\n        return [];\n\n      }\n\n      targetNodes = this.nodes[ 0 ].slice( 0 );\n\n      for ( i = 0, l = depth; i < l; i ++ ) {\n\n        for ( ii = 0, ll = targetNodes.length; ii < ll; ii ++ ) {\n\n          node = targetNodes[ ii ];\n          isIntersected = ns.collision.isIntersectionSphereAABB( sphere, node );\n\n          if ( isIntersected ) {\n\n            isAtMaxDepth = ( i + 1 === depth );\n\n            if ( isAtMaxDepth ) {\n\n              if ( node.trianglePool.length !== 0 ) {\n\n                intersectedNodes.push( node );\n\n              }\n\n            } else {\n\n              tmp = tmp.concat( node.getChildNodes() );\n\n            }\n\n          }\n\n        }\n\n        targetNodes = tmp.slice( 0 );\n        tmp.length = 0;\n\n      }\n\n      return intersectedNodes;\n\n    }\n\n  };\n\n  ns.Octree.separate3Bit = function ( n ) {\n\n    n = ( n | n << 8 ) & 0x0000f00f;\n    n = ( n | n << 4 ) & 0x000c30c3;\n    n = ( n | n << 2 ) & 0x00249249;\n    return n;\n\n  };\n\n  ns.Octree.getMortonNumber = function ( x, y, z ) {\n\n    return ns.Octree.separate3Bit( x ) |\n           ns.Octree.separate3Bit( y ) << 1 |\n           ns.Octree.separate3Bit( z ) << 2;\n\n  };\n\n  ns.Octree.uniqTriangkesfromNodes = function ( nodes ) {\n\n    var i, ii, iii, l, ll, lll, uniq = [], isContained = false;\n\n    if ( nodes.length === 0 ) {\n\n      return [];\n\n    } else if ( nodes.length === 1 ) {\n\n      return nodes[ 0 ].trianglePool.slice( 0 );\n\n    }\n\n    for ( i = 0, l = nodes.length; i < l; i ++ ) {\n\n      for ( ii = 0, ll = nodes[ i ].trianglePool.length; ii < ll; ii ++ ) {\n\n        for ( iii = 0, lll = uniq.length; iii < lll; iii ++ ) {\n\n          if ( nodes[ i ].trianglePool[ ii ] === uniq[ iii ] ) {\n\n            isContained = true;\n\n          }\n\n        }\n\n        if ( !isContained ) {\n\n          uniq.push( nodes[ i ].trianglePool[ ii ] );\n\n        }\n\n        isContained = false;\n\n      }\n\n    }\n\n    return uniq;\n\n  };\n\n  //\n\n  ns.OctreeNode = function ( tree, depth, mortonNumber, min, max ) {\n\n    this.tree = tree;\n    this.depth = depth;\n    this.mortonNumber = mortonNumber;\n    this.min = new THREE.Vector3( min.x, min.y, min.z );\n    this.max = new THREE.Vector3( max.x, max.y, max.z );\n    this.trianglePool = [];\n\n  };\n\n  ns.OctreeNode.prototype = {\n\n    constructor: ns.OctreeNode,\n\n    getParentNode: function () {\n\n      if ( this.depth === 0 ) {\n\n        return null;\n\n      }\n\n      this.tree.nodes[ this.depth ][ this.mortonNumber >> 3 ];\n\n    },\n\n    getChildNodes: function () {\n\n      if ( this.tree.maxDepth === this.depth ) {\n\n        return null;\n\n      }\n\n      var firstChild = this.mortonNumber << 3;\n\n      return [\n        this.tree.nodes[ this.depth + 1 ][ firstChild ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 1 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 2 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 3 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 4 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 5 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 6 ],\n        this.tree.nodes[ this.depth + 1 ][ firstChild + 7 ]\n      ];\n\n    }\n\n  };\n\n  //\n\n  // a: <THREE.Vector3>\n  // b: <THREE.Vector3>\n  // c: <THREE.Vector3>\n  // normal: <THREE.Vector3>\n  // meshID: <String>\n  ns.Face = function ( a, b, c, normal, meshID ) {\n\n    this.a = a.clone();\n    this.b = b.clone();\n    this.c = c.clone();\n    this.normal = normal.clone();\n    this.meshID = meshID;\n\n  };\n\n  ns.Face.prototype = {\n\n    constructor: ns.Face\n\n  };\n\n  // origin   : <THREE.Vector3>\n  // direction: <THREE.Vector3>\n  // distance : <Float>\n  ns.Ray = function ( origin, direction, distance ) {\n    this.origin = origin;\n    this.direction = direction;\n    this.distance = distance;\n  };\n\n} )( THREE, MW );\n\n\n"
			},
			{
				"name": "MWtps.js",
				"source": "// MWtps.js\n\n/*!\n* @author yomotsu http://yomotsu.net/\n* MIT License\n*/\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  ns.CharacterController = function ( object3d, radius ) {\n\n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n    this.object = object3d;\n    this.center = this.object.position.clone();\n    this.radius = radius;\n    this.groundPadding = 0.5;\n    this.maxSlopeGradient = Math.cos( THREE.Math.degToRad( 50 ) );\n    this.isGrounded = false;\n    this.isOnSlope  = false;\n    this.isIdling   = false;\n    this.isRunning  = false;\n    this.isJumping  = false;\n    this.direction  = 0; // 0 to 2PI(=360deg) in rad\n    this.movementSpeed = 28; // default: 50; // Meters Per Second\n    this.velocity = new THREE.Vector3( 0, -10, 0 );\n    this.currentJumpPower = 0;\n    this.jumpStartTime = 0;\n    this.groundHeight = 0;\n    this.groundNormal = new THREE.Vector3();\n    this.collisionCandidate;\n    this.contactInfo = [];\n\n  };\n\n  ns.CharacterController.prototype = {\n\n    constructor: ns.CharacterController,\n\n    update: function ( dt ) {\n\n      this.isGrounded = false;\n      this.isOnSlope  = false;\n      this.groundHeight = -Infinity;\n      this.groundNormal.set( 0, 1, 0 );\n\n      this.updateGrounding();\n      this.updateJumping();\n      this.updatePosition( dt );\n      this.collisionDetection();\n      this.solvePosition();\n      this.updateVelocity();\n      this.events();\n\n    },\n\n    updateVelocity: function () {\n\n      var FALL_VELOCITY = -50,\n          frontDierction = -Math.cos( this.direction ),\n          rightDierction = -Math.sin( this.direction ),\n          normal,\n          isHittingCeiling = false,\n          wallNomal2D,\n          direction2D,\n          wallAngle,\n          frontAngle,\n          negativeFrontAngle,\n          i, l;\n      \n      this.velocity.set(\n        rightDierction * this.movementSpeed * this.isRunning, \n        FALL_VELOCITY,\n        frontDierction * this.movementSpeed * this.isRunning\n      );\n\n      if ( this.contactInfo.length === 0 && !this.isJumping ) {\n\n        return;\n\n      } else if ( this.isGrounded && !this.isOnSlope && !this.isJumping ) {\n\n        this.velocity.y = 0;\n\n      } else if ( this.isOnSlope ) {\n\n        var slidingDownVelocity = FALL_VELOCITY;\n        var holizontalSpead = - slidingDownVelocity / ( 1 - this.groundNormal.y ) * 0.2;\n\n        this.velocity.x = this.groundNormal.x * holizontalSpead;\n        this.velocity.y = FALL_VELOCITY;\n        this.velocity.z = this.groundNormal.z * holizontalSpead;\n\n      } else if ( !this.isGrounded && !this.isOnSlope && this.isJumping ) {\n\n        this.velocity.y = this.currentJumpPower * -FALL_VELOCITY;\n\n      }\n\n\n      // vs walls and sliding on the wall\n      direction2D = new THREE.Vector2( rightDierction, frontDierction );\n      frontAngle = Math.atan2( direction2D.y, direction2D.x );\n      negativeFrontAngle = Math.atan2( -direction2D.y, -direction2D.x );\n      \n      for ( i = 0, l = this.contactInfo.length; i < l; i ++ ) {\n\n        normal = this.contactInfo[ i ].face.normal;\n        // var distance = this.contactInfo[ i ].distance;\n\n        if ( this.maxSlopeGradient < normal.y || this.isOnSlope ) {\n\n          continue;\n\n        }\n\n        if ( !isHittingCeiling && normal.y < 0 ) {\n\n          isHittingCeiling = true;\n\n        }\n\n        wallNomal2D = new THREE.Vector2( normal.x, normal.z ).normalize();\n        wallAngle = Math.atan2( wallNomal2D.y, wallNomal2D.x );\n\n        if (\n          Math.abs( negativeFrontAngle - wallAngle ) >= Math.PI * 0.5 && //  90deg\n          Math.abs( negativeFrontAngle - wallAngle ) <= Math.PI * 1.5    // 270deg\n        ) {\n\n          continue;\n\n        }\n\n        wallNomal2D.set(\n          direction2D.dot( wallNomal2D ) * wallNomal2D.x,\n          direction2D.dot( wallNomal2D ) * wallNomal2D.y\n        );\n        direction2D.subVectors( direction2D, wallNomal2D );\n\n        this.velocity.x = direction2D.x * this.movementSpeed * this.isRunning;\n        this.velocity.z = direction2D.y * this.movementSpeed * this.isRunning;\n\n      }\n\n      if ( isHittingCeiling ) {\n\n        this.velocity.y = Math.min( 0, this.velocity.y );\n        this.isJumping = false;\n\n      }\n\n    },\n\n    updateGrounding: function () {\n\n      // \"頭上からほぼ無限に下方向までの線 (segment)\" vs \"フェイス (triangle)\" の\n      // 交差判定を行う\n      // もし、フェイスとの交差点が「頭上」から「下groundPadding」までの間だったら\n      // 地面上 (isGrounded) にいることとみなす\n      //\n      //   ___\n      //  / | \\\n      // |  |  | player sphere\n      //  \\_|_/\n      //    |\n      //---[+]---- ground\n      //    |\n      //    |\n      //    | segment (player's head to almost -infinity)\n\n\n      var i, l,\n          groundContactInfo,\n          groundContactInfoTmp,\n          faces = this.collisionCandidate,\n          distanceToGround;\n\n      var head = new THREE.Vector3(\n        this.center.x,\n        this.center.y + this.radius,\n        this.center.z\n      );\n\n      var to = new THREE.Vector3(\n        this.center.x,\n        this.center.y - 1e10,\n        this.center.z\n      );\n\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\n\n        groundContactInfoTmp = ns.collision.testSegmentTriangle( head, to, faces[ i ].a, faces[ i ].b, faces[ i ].c );\n\n        if ( groundContactInfoTmp && !groundContactInfo ) {\n\n          groundContactInfo = groundContactInfoTmp;\n          groundContactInfo.face = faces[ i ];\n\n        } else if (\n          groundContactInfoTmp &&\n          groundContactInfoTmp.contactPoint.y > groundContactInfo.contactPoint.y\n        ) {\n          \n          groundContactInfo = groundContactInfoTmp;\n          groundContactInfo.face = faces[ i ];\n\n        }\n\n      }\n\n      if ( !groundContactInfo ) {\n\n        return;\n\n      }\n\n      this.groundHeight = groundContactInfo.contactPoint.y;\n      this.groundNormal.copy( groundContactInfo.face.normal );\n\n      var top    = head.y;\n      var bottom = this.center.y - this.radius - this.groundPadding;\n\n      if ( this.isJumping && 0 < this.currentJumpPower ) {\n\n        this.isOnSlope  = false;\n        this.isGrounded = false;\n        return;\n\n      }\n\n      this.isGrounded = ( bottom <= this.groundHeight && this.groundHeight <= top );\n      this.isOnSlope  = ( this.groundNormal.y <= this.maxSlopeGradient );\n\n      if ( this.isGrounded ) {\n\n        this.isJumping = false;\n\n      }\n\n    },\n\n    updatePosition: function ( dt ) {\n\n      var x = this.center.x + this.velocity.x * dt,\n          y = this.center.y + this.velocity.y * dt,\n          z = this.center.z + this.velocity.z * dt;\n\n      if ( this.isGrounded ) {\n\n        y = this.groundHeight + this.radius;\n\n      }\n\n      this.center.set( x, y, z );\n\n    },\n\n    collisionDetection: function () {\n\n      var i, l,\n          faces = this.collisionCandidate,\n          contactInfo;\n\n      this.contactInfo.length = 0;\n\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\n\n        contactInfo = ns.collision.isIntersectionSphereTriangle( this, faces[ i ].a, faces[ i ].b, faces[ i ].c, faces[ i ].normal );\n\n        if ( !contactInfo ) {\n\n          continue;\n\n        }\n\n        contactInfo.face = faces[ i ];\n        this.contactInfo.push( contactInfo );\n\n      }\n\n    },\n\n    solvePosition: function () {\n\n      var face,\n          normal,\n          distance,\n          point1 = new THREE.Vector3(),\n          point2 = new THREE.Vector3(),\n          direction = new THREE.Vector3(),\n          plainD,\n          t,\n          translateScoped = new THREE.Vector3(),\n          translate = new THREE.Vector3(),\n          i, l;\n\n      if ( this.contactInfo.length === 0 ) {\n\n        this.object.position.copy( this.center );\n        return;\n\n      }\n\n      // \n      // vs walls and sliding on the wall\n\n      for ( i = 0, l = this.contactInfo.length; i < l; i ++ ) {\n\n        face = this.contactInfo[ i ].face;\n        normal = this.contactInfo[ i ].face.normal;\n        distance = this.contactInfo[ i ].distance;\n\n        // if ( 0 <= distance ) {\n\n        //   continue;\n\n        // }\n\n        if ( this.maxSlopeGradient < normal.y ) {\n\n          // this triangle is a ground or slope, not a wall or ceil.\n          continue;\n\n        }\n\n        var isSlopeFace = ( this.maxSlopeGradient <= face.normal.y && face.normal.y < 1 );\n\n        if ( this.isJumping && 0 >= this.currentJumpPower && isSlopeFace ) {\n\n          this.isJumping = false;\n          this.isGrounded = true;\n          // console.log( 'jump end' );\n\n        }\n\n        if ( this.isGrounded || this.isOnSlope ) {\n\n          // http://gamedev.stackexchange.com/questions/80293/how-do-i-resolve-a-sphere-triangle-collision-in-a-given-direction\n          point1.copy( normal ).multiplyScalar( -this.radius ).add( this.center );\n          direction.set( normal.x, 0, normal.z ).normalize();\n          plainD = face.a.dot( normal );\n          t = ( plainD - ( normal.x * point1.x + normal.y * point1.y + normal.z * point1.z ) ) / ( normal.x * direction.x + normal.y * direction.y + normal.z * direction.z );\n          point2.copy( direction ).multiplyScalar( t ).add( point1 );\n          translateScoped.subVectors( point2, point1 );\n\n          if ( Math.abs( translate.x ) > Math.abs( translateScoped.x ) ) {\n\n            translate.x += translateScoped.x;\n\n          }\n\n          if ( Math.abs( translate.z ) > Math.abs( translateScoped.z ) ) {\n\n            translate.z += translateScoped.z;\n\n          }\n\n          // break;\n          continue;\n\n        }\n\n      }\n\n      this.center.add( translate );\n      this.object.position.copy( this.center );\n\n    },\n\n    events: function () {\n\n      var isFirstUpdate = true,\n          wasGrounded,\n          wasOnSlope,\n          wasIdling,\n          wasRunning,\n          wasJumping;\n\n      return function () {\n\n        if ( isFirstUpdate ) {\n\n            isFirstUpdate = false;\n            wasGrounded = this.isGrounded;\n            wasOnSlope  = this.isOnSlope;\n            wasIdling   = this.isIdling;\n            wasRunning  = this.isRunning;\n            wasJumping  = this.isJumping;\n            return;\n\n        }\n\n        if ( !wasRunning && !this.isRunning && this.isGrounded && !this.isIdling ) {\n\n            this.isIdling = true;\n            this.dispatchEvent( { type: 'startIdling' } );\n\n        } else if (\n          ( !wasRunning && this.isRunning && !this.isJumping && this.isGrounded ) ||\n          ( !wasGrounded && this.isGrounded && this.isRunning ) ||\n          ( wasOnSlope && !this.isOnSlope && this.isRunning && this.isGrounded )\n        ) {\n\n            this.isIdling = false;\n            this.dispatchEvent( { type: 'startRunning' } );\n          \n        } else if ( !wasJumping && this.isJumping ) {\n\n            this.isIdling = false;\n            this.dispatchEvent( { type: 'startJumping' } );\n          \n        } else if ( !wasOnSlope && this.isOnSlope ) {\n\n            this.dispatchEvent( { type: 'startSliding' } );\n          \n        } else if ( wasGrounded && !this.isGrounded && !this.isJumping ) {\n\n            this.dispatchEvent( { type: 'startFalling' } );\n          \n        }\n\n        if ( !wasGrounded && this.isGrounded ) {\n\n            this.dispatchEvent( { type: 'endJumping' } );\n          \n        }\n\n        wasGrounded = this.isGrounded;\n        wasOnSlope  = this.isOnSlope;\n        wasIdling   = this.isIdling;\n        wasRunning  = this.isRunning;\n        wasJumping  = this.isJumping;\n\n      };\n\n    }(),\n\n    setDirection : function () {\n\n\n\n    },\n\n    jump: function () {\n      \n      if ( this.isJumping || !this.isGrounded || this.isOnSlope ) {\n\n        return;\n\n      }\n\n      // since ios dose not support porformance.now()\n      // this.jumpStartTime = performance.now();\n      this.jumpStartTime = Date.now();\n      this.currentJumpPower = 0.01;\n      this.isJumping = true;\n\n    },\n\n    updateJumping: function () {\n\n      var JUMP_DURATION = 1500;\n\n      if ( !this.isJumping ) {\n\n        return;\n\n      }\n\n      // since ios dose not support porformance.now()\n      // var elapsed = performance.now() - this.jumpStartTime;\n      var elapsed = Date.now() - this.jumpStartTime;\n      var progress = elapsed / JUMP_DURATION;\n      this.currentJumpPower = Math.cos( Math.min( progress, 1 ) * Math.PI );\n\n    }\n\n  }\n\n} )( THREE, MW );\n\n// @author yomotsu\n// MIT License\n\nMW.AnimationController = function ( mesh ) {\n\n  this.mesh   = mesh;\n  this.motion = {};\n  this.mixer  = new THREE.AnimationMixer( mesh );\n  this.currentMotionName = \"\";\n\n  var i, l, anim;\n\n  for ( i = 0, l = this.mesh.geometry.animations.length; i < l; i ++ ) {\n\n    anim = this.mesh.geometry.animations[ i ];\n    this.motion[ anim.name ] = this.mixer.clipAction( anim );\n    this.motion[ anim.name ].setEffectiveWeight( 1 );\n\n  }\n  \n};\n\nMW.AnimationController.prototype = {\n\n  play: function ( name ) {\n\n    if ( this.currentMotionName === name ) { return; }\n\n    if ( this.motion[ this.currentMotionName ] ) {\n\n      var from = this.motion[ this.currentMotionName ].play();\n      var to   = this.motion[ name ].play();\n\n      from.enabled = true;\n      to.enabled = true;\n\n      from.crossFadeTo( to, .3 );\n\n    } else {\n\n      this.motion[ name ].enabled = true;\n      this.motion[ name ].play();\n\n    }\n\n    this.currentMotionName = name;\n\n  },\n\n  turn: function () {\n\n    var DURATION  = 200;\n    var TAU = 2 * Math.PI;\n\n    var mod = function ( a, n ) { return ( a % n + n ) % n; };\n\n    var getDeltaAngle = function ( current, target ) {\n\n      var a = mod( ( current - target ), TAU );\n      var b = mod( ( target - current ), TAU );\n\n      return a < b ? -a : b;\n\n    };\n\n    return function ( rad, immediate ) {\n\n\n      var that       = this;\n      var progress   = 0;\n      var prevRotY   = this.mesh.rotation.y;\n      var targetRotY = rad;\n      var deltaY     = getDeltaAngle( prevRotY, targetRotY );\n      // var duration   = Math.abs( deltaY ) * 100;\n      var start      = Date.now();\n      var end        = start + DURATION;\n\n      if ( immediate ) {\n\n        this.mesh.rotation.y = targetRotY;\n        return;\n\n      }\n\n      if ( this._targetRotY === targetRotY ) { return; }\n\n      this._targetRotY = targetRotY;\n\n      ( function () {\n\n        var _targetRotY = targetRotY;\n\n        ( function interval () {\n\n          var now = Date.now();\n          var isAborted = _targetRotY !== that._targetRotY;\n\n          if ( isAborted ) { return; }\n\n          if ( now >= end ) {\n\n            that.mesh.rotation.y = _targetRotY;\n            delete that._targetRotY;\n            return;\n\n          }\n\n          requestAnimationFrame( interval );\n          progress = ( now - start ) / DURATION;\n          that.mesh.rotation.y = prevRotY + deltaY * progress;\n\n        } )();\n\n      } )();\n\n    }\n\n  }(),\n\n  update: function ( delta ) {\n\n    this.mixer.update( delta );\n\n  }\n\n};\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  var KEY_W     = 87,\n      KEY_UP    = 38,\n      KEY_S     = 83,\n      KEY_DOWN  = 40,\n      KEY_A     = 65,\n      KEY_LEFT  = 37,\n      KEY_D     = 68,\n      KEY_RIGHT = 39,\n      KEY_SPACE = 32,\n      KEY_R     = 82; // hack //\n\n  var DEG_0   = THREE.Math.degToRad(   0 ),\n      DEG_45  = THREE.Math.degToRad(  45 ),\n      DEG_90  = THREE.Math.degToRad(  90 ),\n      DEG_135 = THREE.Math.degToRad( 135 ),\n      DEG_180 = THREE.Math.degToRad( 180 ),\n      DEG_225 = THREE.Math.degToRad( 225 ),\n      DEG_270 = THREE.Math.degToRad( 270 ),\n      DEG_315 = THREE.Math.degToRad( 315 ),\n      DEG_360 = THREE.Math.degToRad( 360 );\n\n  ns.KeyInputControl = function () {\n    \n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n\n    this.isDisabled = false;\n\n    this.isUp    = false;\n    this.isDown  = false;\n    this.isLeft  = false;\n    this.isRight = false;\n    this.inRun   = false; // hack.\n    this.isMoveKeyHolded = false;\n    this.frontAngle = 0;\n\n    this._keydownListener = onkeydown.bind( this );\n    this._keyupListener   = onkeyup.bind( this );\n    this._blurListener    = onblur.bind( this );\n\n    window.addEventListener( 'keydown', this._keydownListener, false );\n    window.addEventListener( 'keyup',   this._keyupListener,   false );\n    window.addEventListener( 'blur',    this._blurListener,    false );\n\n  };\n\n  ns.KeyInputControl.prototype.jump = function () {\n\n    this.dispatchEvent( { type: 'jumpkeypress' } );\n\n  };\n\n  ns.KeyInputControl.prototype.updateAngle = function () {\n\n    var up    = this.isUp;\n    var down  = this.isDown;\n    var left  = this.isLeft;\n    var right = this.isRight;\n\n    if (  up && !left && !down && !right )      { this.frontAngle = DEG_0  ; }\n    else if (  up &&  left && !down && !right ) { this.frontAngle = DEG_45 ; }\n    else if ( !up &&  left && !down && !right ) { this.frontAngle = DEG_90 ; }\n    else if ( !up &&  left &&  down && !right ) { this.frontAngle = DEG_135; }\n    else if ( !up && !left &&  down && !right ) { this.frontAngle = DEG_180; }\n    else if ( !up && !left &&  down &&  right ) { this.frontAngle = DEG_225; }\n    else if ( !up && !left && !down &&  right ) { this.frontAngle = DEG_270; }\n    else if (  up && !left && !down &&  right ) { this.frontAngle = DEG_315; }\n\n  };\n\n\n  function onkeydown ( e ) {\n\n    if ( this.isDisabled ) { return; }\n\n    switch ( e.keyCode ) {\n\n      case KEY_W :\n      case KEY_UP :\n        this.isUp = true;\n        break;\n\n      case KEY_S :\n      case KEY_DOWN :\n        this.isDown = true;\n        break;\n\n      case KEY_A :\n      case KEY_LEFT :\n        this.isLeft = true;\n        break;\n\n      case KEY_D :\n      case KEY_RIGHT :\n        this.isRight = true;\n        break;\n\n      case KEY_SPACE :\n        this.jump();\n        break;\n\n      default:\n        return;\n\n    }\n    \n    var prevAngle = this.frontAngle;\n\n    this.updateAngle();\n\n    if ( prevAngle !== this.frontAngle ) {\n\n      this.dispatchEvent( { type: 'movekeychange' } );\n\n    }\n\n    if (\n      ( this.isUp || this.isDown || this.isLeft || this.isRight ) &&\n      !this.isMoveKeyHolded\n    ) {\n\n      this.isMoveKeyHolded = true;\n      this.dispatchEvent( { type: 'movekeyon' } );\n\n    }\n\n  }\n\n  function onkeyup ( e ) {\n\n    if ( this.isDisabled ) { return; }\n\n    switch ( e.keyCode ) {\n\n      case KEY_W :\n      case KEY_UP :\n        this.isUp = false;\n        break;\n\n      case KEY_S :\n      case KEY_DOWN :\n        this.isDown = false;\n        break;\n        \n      case KEY_A :\n      case KEY_LEFT :\n        this.isLeft = false;\n        break;\n\n      case KEY_D :\n      case KEY_RIGHT :\n        this.isRight = false;\n        break;\n\n      case KEY_SPACE :\n        break;\n\n      case KEY_R:\n        this.inRun = !this.inRun; // hack //  console.log(\"case KEY_R:\", e.keyCode, this.inRun);\n        break;\n\n      default:\n        return;\n\n    }\n    \n    var prevAngle = this.frontAngle;\n\n    this.updateAngle();\n\n    if ( prevAngle !== this.frontAngle ) {\n\n      this.dispatchEvent( { type: 'movekeychange' } );\n\n    }\n\n    if ( !this.isUp && !this.isDown && !this.isLeft && !this.isRight &&\n      (\n           e.keyCode === KEY_W\n        || e.keyCode === KEY_UP\n        || e.keyCode === KEY_S\n        || e.keyCode === KEY_DOWN\n        || e.keyCode === KEY_A\n        || e.keyCode === KEY_LEFT\n        || e.keyCode === KEY_D\n        || e.keyCode === KEY_RIGHT\n      )\n    ) {\n\n      this.isMoveKeyHolded = false;\n      this.dispatchEvent( { type: 'movekeyoff' } );\n\n    }\n\n  }\n\n  function onblur ( e ) {\n\n    this.isUp    = false;\n    this.isDown  = false;\n    this.isLeft  = false;\n    this.isRight = false;\n//  this.inRun   = false; // hack // DO NOT SET TO FALSE ON BLUR. //\n    \n    if ( this.isMoveKeyHolded ) {\n\n      this.isMoveKeyHolded = false;\n      this.dispatchEvent( { type: 'movekeyoff' } );\n\n    }\n\n  }\n\n} )( THREE, MW );\n\n// @author yomotsu\n// MIT License\n\n;( function ( THREE, ns ) {\n\n  'use strict';\n\n  var PI2     = Math.PI * 2,\n      PI_HALF = Math.PI / 2;\n\n  var modulo = function ( n, d ) {\n\n    return ( ( n % d ) + d ) % d;\n\n  };\n\n  // camera              isntance of THREE.Camera\n  // trackObject         isntance of THREE.Object3D\n  // params.el           DOM element\n  // params.radius       number\n  // params.minRadius    number\n  // params.maxRadius    number\n  // params.rigidObjects array of inctances of THREE.Mesh\n  ns.TPSCameraControl = function ( camera, trackObject, params ) {\n\n    Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n    this.camera = camera;\n    this.trackObject  = trackObject;\n    this.el           = params && params.el || document.body;\n    this.offset       = params && params.offset || new THREE.Vector3( 0, 0, 0 ),\n    this.radius       = params && params.radius    || 10;\n    this.minRadius    = params && params.minRadius || 1;\n    this.maxRadius    = params && params.maxRadius || 30;\n    this.rigidObjects = params && params.rigidObjects || [];\n    this.lat   = 0;\n    this.lon   = 0;\n    this.phi   = 0; // angle of zenith\n    this.theta = 0; // angle of azimuth\n    this.mouseAccelerationX = params && params.mouseAccelerationX !== undefined ? params.mouseAccelerationX : 100;\n    this.mouseAccelerationY = params && params.mouseAccelerationY !== undefined ? params.mouseAccelerationY : 30;\n    this._pointerStart = { x: 0, y: 0 };\n    this._pointerLast  = { x: 0, y: 0 };\n\n    this.setNearPlainCornersWithPadding();\n    this.update();\n\n    this._mousedownListener = onmousedown.bind( this );\n    this._mouseupListener   = onmouseup.bind( this );\n    this._mousedragListener = onmousedrag.bind( this );\n    this._scrollListener    = onscroll.bind( this );\n\n    this.el.addEventListener( 'mousedown', this._mousedownListener, false );\n    this.el.addEventListener( 'mouseup',   this._mouseupListener,   false );\n    this.el.addEventListener( 'mousewheel',     this._scrollListener, false );\n    this.el.addEventListener( 'DOMMouseScroll', this._scrollListener, false );\n\n  };\n\n  ns.TPSCameraControl.prototype = {\n\n    constructor: ns.TPSCameraControl,\n\n    update: function () {\n\n      var position,\n          distance;\n\n      this._center = new THREE.Vector3(\n        this.trackObject.matrixWorld.elements[ 12 ] + this.offset.x,\n        this.trackObject.matrixWorld.elements[ 13 ] + this.offset.y,\n        this.trackObject.matrixWorld.elements[ 14 ] + this.offset.z\n      );\n      position = new THREE.Vector3(\n        Math.cos( this.phi ) * Math.cos( this.theta + PI_HALF ),\n        Math.sin( this.phi ),\n        Math.cos( this.phi ) * Math.sin( this.theta + PI_HALF )\n      );\n      distance = this.collisionTest( position.clone().normalize() );\n      position.multiplyScalar( distance );\n      position.add( this._center );\n      this.camera.position.copy( position );\n\n      if ( this.lat === 90 ) {\n\n        this.camera.up.set(\n          Math.cos( this.theta + Math.PI ),\n          0,\n          Math.sin( this.theta + Math.PI )\n        );\n\n      } else if ( this.lat === -90 ) {\n\n        this.camera.up.set(\n          Math.cos( this.theta ),\n          0,\n          Math.sin( this.theta )\n        );\n\n      } else {\n\n        this.camera.up.set( 0, 1, 0 );\n\n      }\n\n      this.camera.lookAt( this._center );\n      this.dispatchEvent( { type: 'updated' } );\n\n    },\n\n    getFrontAngle: function () {\n\n      return PI2 + this.theta;\n\n    },\n\n    setNearPlainCornersWithPadding: function () {\n\n      var near = this.camera.near,\n          halfFov = this.camera.fov * 0.5,\n          h = ( Math.tan( THREE.Math.degToRad( halfFov ) ) * near ),\n          w = h * this.camera.aspect;\n\n      this.nearPlainCornersWithPadding = [\n        new THREE.Vector3( -w - near, -h - near, 0 ),\n        new THREE.Vector3(  w + near, -h - near, 0 ),\n        new THREE.Vector3(  w + near,  h + near, 0 ),\n        new THREE.Vector3( -w - near,  h + near, 0 )\n      ];\n\n    },\n\n    setLatLon: function ( lat, lon ) {\n\n      this.lat = lat >  90 ?  90 :\n                 lat < -90 ? -90 :\n                 lat;\n      this.lon = lon < 0 ? 360 + lon % 360 : lon % 360;\n\n      this.phi   =  THREE.Math.degToRad( this.lat );\n      this.theta = -THREE.Math.degToRad( this.lon );\n\n    },\n\n    collisionTest: function ( direction ) {\n\n      var i,\n          distance = this.radius,\n          nearPlainCorner,\n          rotationMatrix = new THREE.Matrix4(),\n          rotationX = new THREE.Matrix4().makeRotationX( this.phi ),\n          rotationY = new THREE.Matrix4().makeRotationY( this.theta ),\n          origin,\n          raycaster,\n          intersects;\n\n      rotationMatrix.multiplyMatrices( rotationX, rotationY );\n\n      for ( i = 0; i < 4; i ++ ) {\n\n        nearPlainCorner = this.nearPlainCornersWithPadding[ i ].clone();\n        nearPlainCorner.applyMatrix4( rotationMatrix );\n\n        origin = new THREE.Vector3(\n          this._center.x + nearPlainCorner.x,\n          this._center.y + nearPlainCorner.y,\n          this._center.z + nearPlainCorner.z\n        );\n        raycaster = new THREE.Raycaster(\n          origin,           // origin\n          direction,        // direction\n          this.camera.near, // near\n          this.radius       // far\n        );\n        intersects = raycaster.intersectObjects( this.rigidObjects );\n\n        if ( intersects.length !== 0 && intersects[ 0 ].distance < distance ) {\n\n          distance = intersects[ 0 ].distance;\n\n        }\n\n      }\n\n      return distance;\n\n    }\n\n  };\n\n  function onmousedown ( event ) {\n\n    this.dispatchEvent( { type: 'mousedown' } );\n    this._pointerStart.x = event.clientX;\n    this._pointerStart.y = event.clientY;\n    this._pointerLast.x = this.lon;\n    this._pointerLast.y = this.lat;\n    this.el.removeEventListener( 'mousemove', this._mousedragListener, false );\n    this.el.addEventListener( 'mousemove', this._mousedragListener, false );\n//  document.body.className += ' js-TPSCameraDragging';\n    document.body.classList.add(\"js-TPSCameraDragging\");\n\n  }\n\n  function onmouseup () {\n\n    this.dispatchEvent( { type: 'mouseup' } );\n    this.el.removeEventListener( 'mousemove', this._mousedragListener, false );\n//  document.body.className = document.body.className.replace( / js-TPSCameraDragging/g, '' );\n    document.body.classList.remove(\"js-TPSCameraDragging\");\n\n  }\n\n  function onmousedrag ( event ) {\n\n    var w = this.el.offsetWidth,\n        h = this.el.offsetHeight,\n        x = ( this._pointerStart.x - event.clientX ) / w * 2,\n        y = ( this._pointerStart.y - event.clientY ) / h * 2;\n\n    this.setLatLon(\n      this._pointerLast.y + y * this.mouseAccelerationY,\n      this._pointerLast.x + x * this.mouseAccelerationX\n    );\n\n  }\n\n  function onscroll ( event ) {\n\n    event.preventDefault();\n\n    if ( event.wheelDeltaY ) {\n\n      // WebKit\n      this.radius -= event.wheelDeltaY * 0.05;\n\n    } else if ( event.wheelDelta ) {\n\n      // IE\n      this.radius -= event.wheelDelta * 0.05 ;\n\n    } else if ( event.detail ) {\n\n      // Firefox\n      this.radius += event.detail;\n\n    }\n\n    this.radius = Math.max( this.radius, this.minRadius );\n    this.radius = Math.min( this.radius, this.maxRadius );\n\n  }\n\n} )( THREE, MW );\n"
			},
			{
				"name": "VirtualInput.js",
				"source": "/*!\n * @author yomotsu http://yomotsu.net/\n * MIT License\n */\n\nvirtualInput = {};\n\n( function ( ns ) {\n\n    var _ua = function () {\n        return {\n            Touch: typeof document.ontouchstart != \"undefined\",\n            Pointer: window.navigator.pointerEnabled,\n            MSPoniter: window.navigator.msPointerEnabled\n        }\n    };\n\n    ns._start = \"pointerdown MSPointerDown touchstart mousedown\";\n    ns._move  = \"pointermove MSPointerMove touchmove  mousemove\";\n    ns._end   = \"pointerup   MSPointerUp   touchend   mouseup\";\n\n    ns.Joystick = function ( $container, size, params ) {\n\n        Object.assign( this, THREE.EventDispatcher.prototype );  //  THREE.EventDispatcher.prototype.apply( this );\n\n        this.angle = 0;\n        this.position = { x: 0, y: 0 };\n        this.pointerId = null;\n        this.isActive = false;\n\n        this.width = size * 2;\n        this.halfWidth = size;\n\n        var that = this;\n        var id = params && params.id ? params.id  : '';\n        var template = [\n          '<div class=\"gameinput-joystick\" id=\"' + id + '\">',\n            '<div class=\"gameinput-joystick__button\"></div>',\n            '<svg class=\"gameinput-frame\" width=\"' + this.width + '\" height=\"' + this.width + '\" viewbox=\"0 0 64 64\">',\n              '<polygon points=\"32 19 34 21 30 21\" fill=\"#fff\"></polygon>',\n              '<polygon points=\"45 32 43 34 43 30\" fill=\"#fff\"></polygon>',\n              '<polygon points=\"32 45 34 43 30 43\" fill=\"#fff\"></polygon>',\n              '<polygon points=\"19 32 21 34 21 30\" fill=\"#fff\"></polygon>',\n              '<circle cx=\"32\" cy=\"32\" r=\"16\" fill=\"none\" stroke=\"#fff\" stroke-width=\"' + ( this.halfWidth / 64 ) + '\"></circle>',\n            '</svg>',\n          '</div>'\n        ].join( '' );\n\n        var $win = $( window );\n        this.$all = $( template );\n        this.$button = this.$all.find( \".gameinput-joystick__button\" );\n        $container.append( this.$all );\n\n        this.$all.css({\n            width:  this.width,\n            height: this.width\n        });\n\n        this.$button.css({\n            width:  size * .6,\n            height: size * .6\n        });\n\n        this.offset = this.$all.offset();\n        this.buttonRadius = this.$button.width() / 2;\n        this.frameRadius = size / 2;\n    //  this.position = { x: 0, y: 0 };\n\n        var onbuttondown = function ( event ) {\n\n            event.preventDefault();\n            event.stopPropagation();\n            \n            that.dispatchEvent( { type: 'active' } );\n            that.isActive = true;\n            \n            if ( event.originalEvent.pointerId ) {\n            \n                that.pointerId = event.originalEvent.pointerId;\n            \n            } else if ( event.originalEvent.changedTouches ) {\n            \n                that.pointerId = event.originalEvent.changedTouches[ event.originalEvent.changedTouches.length - 1 ].identifier;\n            \n            }\n            \n            var coordinate = that.getEventCoordinate( event );\n            \n            if ( !coordinate ) { return; }\n            \n            that.setPosition( coordinate.x, coordinate.y );\n            \n            $win.on( ns._move, onbuttonmove );\n            $win.on( ns._end,  onbuttonup );\n\n        };\n\n        var onbuttonmove = function ( event ) {\n\n            event.preventDefault();\n            event.stopPropagation();\n            \n            var coordinate = that.getEventCoordinate( event );\n            \n            if ( !coordinate ) {\n                return;\n            }\n            \n            that.setPosition( coordinate.x, coordinate.y );\n\n        };\n\n        var onbuttonup = function ( event ) {\n\n            event.stopPropagation();\n\n            var wasEventHappend;\n\n            if ( event.originalEvent.pointerId ) {\n\n                if ( that.pointerId !== event.originalEvent.pointerId ) {\n                    return;\n                }\n\n            } else if ( event.originalEvent.changedTouches ) {\n            \n                for ( i = 0, l = event.originalEvent.changedTouches.length; i < l; i ++ ) {\n                \n                    if ( that.pointerId === event.originalEvent.changedTouches[ i ].identifier ) {\n                        wasEventHappend = true;\n                        break;\n                    }\n                \n                    if ( !wasEventHappend ) {\n                        return;\n                    }\n                \n                }\n            \n            }\n\n            that.dispatchEvent( { type: \"disactive\" } );\n            that.isActive = false;\n            that.setPosition( 0, 0 );\n            $win.off( ns._move, onbuttonmove );\n            $win.off( ns._end,  onbuttonup );\n\n        };\n\n        this.setCSSPosition( 0, 0 );\n        this.$all.on( ns._start, onbuttondown );\n\n        $win.on( \"resize\", function () {\n\n            that.offset = that.$all.offset();\n\n        });\n\n    };\n\n    ns.Joystick.prototype.getLength = function ( x, y ) {\n        return Math.sqrt( Math.pow( x, 2 ) + Math.pow( y, 2 ) );\n    };\n\n    ns.Joystick.prototype.getAngle = function ( lengthX, lengthY ) {\n\n        if ( lengthX === 0 && lengthY === 0 ) {\n          return this.angle;\n        }\n\n        var angle = Math.atan( lengthY / lengthX );\n\n        if ( 0 > lengthX && 0 <= lengthY ) {\n          //the second quadrant\n          angle += Math.PI;\n\n        } else if ( 0 > lengthX && 0 > lengthY ) {\n          //the third quadrant\n          angle += Math.PI;\n\n        } else if ( 0 <= lengthX && 0 > lengthY ) {\n          //the fourth quadrant\n          angle += Math.PI * 2;\n\n        }\n\n        this.angle = angle;\n        return angle;\n\n    };\n\n    ns.Joystick.prototype.getPointOnRadius = function ( angle ) {\n\n        return {\n          x: Math.cos( angle ),\n          y: Math.sin( angle )\n        };\n\n    };\n\n    ns.Joystick.prototype.getEventCoordinate = function ( event ) {\n\n        var x, y, _event = null, i, l;\n\n        if ( event.originalEvent.pointerId ) {\n\n            if ( this.pointerId === event.originalEvent.pointerId ) {\n                _event = event.originalEvent;\n            }\n\n        } else if ( event.originalEvent.changedTouches ) {\n\n            for ( i = 0, l = event.originalEvent.changedTouches.length; i < l; i ++ ) {\n                if ( this.pointerId === event.originalEvent.changedTouches[ i ].identifier ) {\n                  _event = event.originalEvent.changedTouches[ i ];\n                }\n            }\n\n        } else {\n\n            _event = event;\n\n        }\n\n        if ( _event === null ) {\n            return false;\n        }\n\n        x = (   ( _event.clientX - this.offset.left ) - this.halfWidth ) / this.halfWidth * 2;\n        y = ( - ( _event.clientY - this.offset.top  ) + this.halfWidth ) / this.halfWidth * 2;\n\n        return { x: x, y: y };\n\n    };\n\n    ns.Joystick.prototype.setPosition = function ( x, y ) {\n\n        this.position.x = x;\n        this.position.y = y;\n        var length = this.getLength( x, y );\n        var angle = this.getAngle( x, y );\n\n        if ( 1 >= length ) {\n            this.setCSSPosition( x, y );\n            return;\n        }\n\n        var pointOnRadius = this.getPointOnRadius( angle );\n        this.setCSSPosition( pointOnRadius.x, pointOnRadius.y );\n\n    };\n\n    ns.Joystick.prototype.setCSSPosition = function ( x, y ) {\n\n        this.$button.css( {\n            left: ( this.halfWidth + x * this.frameRadius - this.buttonRadius ),\n            top:  ( this.halfWidth - y * this.frameRadius - this.buttonRadius )\n        });\n\n    };\n\n    ns.Button = function ( $container, size, params ) {\n\n        Object.assign( this, THREE.EventDispatcher.prototype );  // THREE.EventDispatcher.prototype.apply( this );\n\n        var that = this;\n        var id = params && params.id ? params.id  : \"\";\n        var label = params.label;\n        var template = [\n          '<div class=\"gameinput-button\" id=\"' + id + '\">',\n            '<div class=\"gameinput-button__inner\">',\n              label,\n            '</div>',\n          '</div>'\n        ].join( \"\" );\n        var $button = $( template );\n        $container.append( $button );\n        $button.css( {\n            width: size,\n            height: size\n        });\n\n        $button.on( ns._start, function () {\n            that.dispatchEvent( { type: \"press\" } );\n        });\n\n    };\n\n})( virtualInput );\n"
			},
			{
				"name": "OutfitManager.js",
				"source": "//  OutfitManager.js\n\nOutfitManager = function( direction ){\n\n\tvar self = this;\n\n\tvar Signal = signals.Signal;\n\tthis.added = new Signal();\n\tthis.removed = new Signal();\n\tthis.changed = new Signal();\n\tthis.genderChanged = new Signal();\n\tthis.genderIsChanging = new Signal();\n\n\tthis.eventTimeout = undefined;\n\n\tthis.gender = {\n\t\tmale    : false,\n\t\tfemale  : false,\n\t\tshemale : false,\n\t\ttrans   : false,\n\t};\n\n\tthis.genitals = { \n\t\tvagina   : false,\n\t\tpenis    : false,\n\t\tattached : false,\n\t};\n\n\tthis.layers = [\n\t\t\"body\", \"head\",\n\t\t\"face\", \"hairs\", \"upper\",\n\t\t\"lower\", \"torso\", \"arms\",\n\t\t\"legs\", \"hands\", \"feet\",\n\t\t\"genitals\", \"skeleton\",\n\t];\n\n\tthis.slots = [\n\t\t\"skeleton\", \"body\", \"hairs\",\n\t\t\"eyes\", \"glasses\", \"hat\",\n\t\t\"bra\", \"panties\", \"stockings\",\n\t\t\"underwears\", \"costume\",\n\t\t\"tshirt\", \"skirt\", \"trousers\",\n\t\t\"skirt\", \"dress\", \"shoes\",\n\t\t\"coat\", \"penis\", \"vagina\",\n\t];\n\n\tthis.stickers = [\n\t\t\"skin\", \"makeup\", \"tattoo\", \"bodypaint\",\n\t\t\"neck\", \"chest\", \"belly\", \"upperlimb\",\n\t\t\"arm\", \"forearm\", \"wrist\", \"hand\",\n\t\t\"lowerlimb\", \"thigh\", \"leg\", \"foot\",\n\t\t\"butt\", \"back\", \"scapula\", \"lumbar\",\n\t];\n\n\tthis.attachments = [\n\t\t\"helmet\", \"face\", \"mask\", \"teeth\",\n\t\t\"beard\", \"eyelash\", \"glasses\", \"ears\",\n\t\t\"belly\", \"gun\", \"wepon\", \"knife\", \"sword\",\n\t\t\"bistol\", \"watch\", \"jewelry\", \"earings\",\n\t\t\"necklace\", \"bracelet\", \"bag\", \"handbag\",\n\t\t\"cape\", \"coat\", \"horn\", \"tail\", \"penis\", \n\t];\n\n\n\n};\n"
			}],
		"037ED138-2B13-485A-A232-9113F54FF3B2": [
			{
				"name": "octree.js",
				"source": "//\toctree.js\n\nvar partition = 1;\n\nvar min = new THREE.Vector3( -5000, -1000, -5000 );\nvar max = new THREE.Vector3(  5000,  1000,  5000 );\n\noctree = new MW.Octree( min, max, partition );\n\n//\tHELPERS.\n\nvar octMeshHelpers = [];\nvar octEdgeHelpers = [];\n\nfunction octreeHelpers( octree ){\n\tvar nodeIndex = octree.nodes.length - 1;\n\tvar node = octree.nodes[ nodeIndex ][0];\n\tvar x = node.max.x - node.min.x;\n\tvar y = node.max.y - node.min.y;\n\tvar z = node.max.z - node.min.z;\n\tvar geometry = new THREE.BoxGeometry(x, y, z);\n\tvar material = new THREE.MeshBasicMaterial({visible:false});\n\n\toctree.nodes[ nodeIndex ].forEach(function(node){\n\n\t\tvar x = node.max.x - node.min.x;\n\t\tvar y = node.max.y - node.min.y;\n\t\tvar z = node.max.z - node.min.z;\n\n\t\tvar mesh = new THREE.Mesh(geometry, material);\n\t\tvar helper = new THREE.EdgesHelper( mesh, 0xffff00 );\n\n\t\tmesh.position.set(\n\t\t\tnode.min.x + (x/2),\n\t\t\tnode.min.y + (y/2),\n\t\t\tnode.min.z + (z/2)\n\t\t);\n\n\t\t//  scene.add( mesh );\n\t\tscene.add( mesh, helper );\n\n\t\toctMeshHelpers.push(mesh);\n\t\toctEdgesHelpers.push(helper);\n\t});\n}\n\nfunction octreeNodeHelper( node ){\n\tvar x = node.max.x - node.min.x;\n\tvar y = node.max.y - node.min.y;\n\tvar z = node.max.z - node.min.z;\n\tvar geometry = new THREE.BoxGeometry(x, y, z);\n\tvar material = new THREE.MeshBasicMaterial({visible:false});\n\tvar mesh = new THREE.Mesh(geometry, material);\n\tmesh.position.set(\n\t\tnode.min.x + (x/2),\n\t\tnode.min.y + (y/2),\n\t\tnode.min.z + (z/2)\n\t);\n\tscene.add( mesh );\n\toctMeshHelpers.push(mesh);\n\tvar helper = new THREE.EdgesHelper( mesh, 0xffff00 );\n\thelper.name = \"octree helper\";\n\tscene.add( helper );\n\toctEdgesHelpers.push(helper);\n}\n\n//  Remove octree mesh helpers.\n\nfunction removeOctreeHelpers(){\n\toctMeshHelpers.forEach( function( item, i ){\n\t\tscene.remove( octMeshHelpers[i] );\n\t\tvar geometry = octMeshHelpers[i].geometry;\n\t\tvar material = octMeshHelpers[i].material;\n\t\tgeometry.dispose();\n\t\tmaterial.dispose();\n\t});\n\tconsole.log( \"octree mesh helpers has been removed.\" );\n}\n"
			},
			{
				"name": "world.js",
				"source": "//\tWORLD.\n\nworld = new MW.World();\nworld.add( octree );\n\n\n//\tUPDATE.\n\nvar clock = new THREE.Clock(); // important!\n\nfunction update(){\n\n\tvar delta = clock.getDelta();\n\n\tworld.step( delta );\n\n}\n"
			},
			{
				"name": "ground.js",
				"source": "//\tground.js\n\nvar ground = new THREE.Mesh(\n\tnew THREE.PlaneGeometry( 10000, 10000, 1, 1 ),\n\tnew THREE.MeshLambertMaterial({ \n\t\topacity:1, \n\t\tcolor:0x829ec4,\n\t})\n);\n\n//\tWe need only the geometry of the ground\n//\tso there is not need to add to the scene.\n\nground.rotation.x = -Math.PI / 2; // THREE.Math.degToRad( -90 );\noctree.importThreeMesh( ground ); // important!\n"
			},
			{
				"name": "groundHelper.js",
				"source": "this.add( new THREE.GridHelper( 1000, 100, 0x444444, 0x444444 ) );\n"
			}]
	}
}